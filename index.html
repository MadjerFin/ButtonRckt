<style>
  #usernameInput:focus {
    outline: none;
    border-color: #4CAF50;
    box-shadow: 0 0 5px #4CAF50AA;
  }

  #increaseLimitBtn {
    padding: 10px 20px;
    font-size: 16px;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    transition: background-color 0.3s;
  }

  #increaseLimitBtn:disabled {
    background-color: #8BCF8C;
    cursor: not-allowed;
  }

  #increaseLimitBtn:hover:not(:disabled) {
    background-color: #45a049;
  }
</style>

<button id="increaseLimitBtn">Puxar Conversa</button>

<script>
  const API_BASE = "https://sapios.chat/api/v1";
  const X_Auth_Token = "xxxxxxxxxxxxxxxxxxxxxxxx";
  const X_User_Id   = "xxxxxxxxxxx";
  const RESTORE_MS  = 10000; // 10s para restaurar

  const btn = document.getElementById("increaseLimitBtn");

  // ========= HTTP helpers =========
  async function fetchWithAuth(url, options = {}) {
    options.headers = {
      ...options.headers,
      "X-Auth-Token": X_Auth_Token,
      "X-User-Id": X_User_Id,
    };
    const res = await fetch(url, options);
    if (!res.ok) throw new Error(`Erro na requisição: ${res.status}`);
    return res.json();
  }

  // ========= Rocket.Chat helpers =========
  async function getUserByUsername(username) {
    const data = await fetchWithAuth(`${API_BASE}/users.info?username=${encodeURIComponent(username)}`);
    if (!data.user) throw new Error(`Usuário não encontrado: ${username}`);
    return data.user; // {_id, username, ...}
  }

  async function getAgentLivechatInfo(agentId) {
    const data = await fetchWithAuth(`${API_BASE}/livechat/users/agent/${encodeURIComponent(agentId)}`);
    if (!data.user) throw new Error("Agente não encontrado");
    return data.user; // { livechat: { maxNumberSimultaneousChat, ... } }
  }

  async function getOpenChats(agentId) {
    const url = `${API_BASE}/livechat/rooms?agents[]=${agentId}&open=true&queued=false&onhold=false&count=100&sort={"ts":-1}`;
    const data = await fetchWithAuth(url);
    return data.rooms ? data.rooms.length : 0;
  }

  // Retorna [{departmentId, department?}] — mantém completo para possíveis filtros
  async function getAgentDepartments(userId) {
    const res = await fetch(`${API_BASE}/livechat/agents/${encodeURIComponent(userId)}/departments`, {
      headers: { "X-Auth-Token": X_Auth_Token, "X-User-Id": X_User_Id }
    });
    if (!res.ok) throw new Error("Erro ao buscar departamentos do agente");
    const data = await res.json();
    return data.departments || [];
  }

  async function updateAgentLimit(agentId, agentData, newLimit) {
    const deps = await getAgentDepartments(agentId);
    const departmentIds = deps.map(d => d.departmentId);

    const bodyData = {
      message: JSON.stringify({
        msg: "method",
        id: "14",
        method: "livechat:saveAgentInfo",
        params: [
          agentId,
          {
            name: agentData.livechat?.name,
            username: agentData.livechat?.username,
            email: agentData.livechat?.email || `${agentData.livechat?.username}@sapios.com.br`,
            maxNumberSimultaneousChat: String(newLimit),
            voipExtension: agentData.livechat?.voipExtension || "",
          },
          departmentIds
        ],
      }),
    };

    const res = await fetch(`${API_BASE}/method.call/livechat%3AsaveAgentInfo`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-Auth-Token": X_Auth_Token,
        "X-User-Id": X_User_Id,
      },
      body: JSON.stringify(bodyData),
    });

    if (!res.ok) throw new Error("Erro ao atualizar limite");
    return await res.json();
  }

  // Lista TODOS os agentes Livechat com paginação
  async function getAllAgents() {
    const pageSize = 100;
    let offset = 0;
    let total = Infinity;
    const users = [];
    while (offset < total) {
      const data = await fetchWithAuth(`${API_BASE}/livechat/users/agent?offset=${offset}&count=${pageSize}`);
      const page = data.users || [];
      users.push(...page); // mantém { _id, username, ... }
      total = typeof data.total === "number" ? data.total : users.length;
      offset += page.length;
      if (page.length === 0) break;
    }
    // remove sem username
    return users.filter(u => !!u.username);
  }

  // ========= Resolução de alvos a partir da API / URL =========
  async function resolveTargets() {
    const qs = new URLSearchParams(location.search);
    const agentsQS = (qs.get("agents") || "")
      .split(",").map(s => s.trim()).filter(Boolean); // usernames
    const deptIdsQS = (qs.get("deptId") || "")
      .split(",").map(s => s.trim()).filter(Boolean); // departmentId(s) para filtrar (opcional)

    // Se veio lista explícita de agentes na URL, usa ela.
    if (agentsQS.length) {
      // converte para objetos {_id, username} usando users.info
      const arr = [];
      for (const username of agentsQS) {
        try {
          const user = await getUserByUsername(username);
          arr.push({ _id: user._id, username: user.username });
        } catch (e) {
          console.error(`Ignorando ${username}: ${e.message}`);
        }
      }
      return arr;
    }

    // Caso contrário, busca todos os agentes via API
    const all = await getAllAgents();

    // Se não houver filtro de departamento, retorna todos
    if (!deptIdsQS.length) return all;

    // Filtra por departamentoId (faz 1 chamada por agente)
    const result = [];
    for (const ag of all) {
      try {
        const deps = await getAgentDepartments(ag._id);
        const agentDepIds = deps.map(d => d.departmentId);
        const match = deptIdsQS.some(id => agentDepIds.includes(id));
        if (match) result.push(ag);
      } catch (e) {
        console.warn(`Falha ao checar departamentos de ${ag.username}:`, e.message);
      }
    }
    return result;
  }

  // ========= Fluxo por agente =========
  async function processAgent(agentUsername) {
    // 1) user + id
    const user = await getUserByUsername(agentUsername);
    const agentId = user._id;

    // 2) Info Livechat
    const agentData = await getAgentLivechatInfo(agentId);

    // 3) Conversas abertas
    const openChats = await getOpenChats(agentId);

    // 4) Limite atual
    const currentLimit = Number(agentData.livechat?.maxNumberSimultaneousChat) || 0;

    console.log(`Agente: ${agentUsername} | Conversas abertas: ${openChats} | Limite atual: ${currentLimit}`);

    if (openChats >= currentLimit) {
      const newLimit = openChats + 1;

      // 5) Aumenta
      await updateAgentLimit(agentId, agentData, newLimit);

      // 6) Restaura depois de RESTORE_MS
      setTimeout(async () => {
        try {
          await updateAgentLimit(agentId, agentData, currentLimit);
        } catch (e) {
          console.error(`Erro ao restaurar limite de ${agentUsername}:`, e);
        }
      }, RESTORE_MS);
    } else {
      console.log(`(${agentUsername}) Limite atual (${currentLimit}) já cobre as abertas (${openChats}).`);
    }
  }

  // ========= Init + clique =========
  let TARGETS = []; // [{_id, username}]

  (async function init() {
    try {
      TARGETS = await resolveTargets();
      if (!TARGETS.length) {
        console.warn("Nenhum agente encontrado (verifique permissões da API, deptId/agents na URL).");
      }
      btn.disabled = TARGETS.length === 0;
    } catch (e) {
      console.error("Falha ao inicializar alvos:", e);
      btn.disabled = true;
    }
  })();

  btn.addEventListener("click", async () => {
    if (!TARGETS.length) {
      alert("Nenhum agente alvo. Use ?agents=a,b,c ou ?deptId=DEP_ID para filtrar; sem parâmetros, busca todos.");
      return;
    }

    btn.disabled = true;
    try {
      // Executa SEQUENCIALMENTE (evita rate limit)
      for (const ag of TARGETS) {
        try {
          await processAgent(ag.username);
        } catch (e) {
          console.error(`Erro ao processar ${ag.username}:`, e);
          alert(`(${ag.username}) Erro: ${e.message}`);
        }
      }
    } finally {
      btn.disabled = false;
    }
  });
</script>
